{"(metadata)":{"source":["meta"],"authors":[{"name":"Thomas Sawyer","email":"transfire@gmail.com"}],"copyrights":[{"holder":"Thomas Sawyer","year":"2009","license":"BSD-2-Clause"}],"replacements":[],"alternatives":[],"requirements":[{"name":"qed","groups":["test"],"development":true},{"name":"detroit","groups":["build"],"development":true}],"dependencies":[],"conflicts":[],"repositories":[],"resources":{"Homepage":"http://rubyworks.github.com/strmask","Source Code":"http://github.com/rubyworks/strmask","Mailing List":"http://groups.google.com/group/rubyworks-mailinglist"},"extra":{},"load_path":["lib"],"revision":0,"created":"2009-07-19","summary":"String Algebra","title":"String::Mask","version":"0.3.2","name":"strmask","description":"String::Mask provides a kind-of string algebra useful for manipulating strings\nin comparitive ways, eg. add, subtract, xor, etc.","organization":"RubyWorks","date":"2011-10-27","path":"(metadata)","markup":"rdoc"},"String":{"!":"class","superclass":"Object","path":"String","name":"String","namespace":"","comment":"require 'facets/functor'","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["String::Mask"],"methods":["String#mask"],"accessors":[],"files":["/lib/strmask.rb"],"tags":{}},"String#mask":{"!":"method","declarations":["instance","public"],"path":"String#mask","name":"mask","namespace":"String","comment":"Create a mask.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mask(re=nil)","arguments":[{"name":"re","default":"nil"}]}],"returns":[],"file":"/lib/strmask.rb","line":6,"source":"def mask(re=nil)\n  Mask.new(self,re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask":{"!":"class","superclass":"Object","path":"String::Mask","name":"Mask","namespace":"String","comment":"= Mask\n\n--\nTODO: Probably need to create a proper #hash method.\n++","format":"rdoc","constants":["String::Mask::VERSION","String::Mask::ESC"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["String::Mask.[]","String::Mask#initialize","String::Mask#to_str","String::Mask#to_s","String::Mask#inspect","String::Mask#[]","String::Mask#mask","String::Mask#mask!","String::Mask#-","String::Mask#+","String::Mask#|","String::Mask#*","String::Mask#&","String::Mask#^","String::Mask#==","String::Mask#apply","String::Mask#replace","String::Mask#method_missing","String::Mask#convert"],"accessors":[],"files":["/lib/strmask.rb"],"tags":{}},"String::Mask::VERSION":{"!":"constant","path":"String::Mask::VERSION","name":"VERSION","namespace":"String::Mask","comment":"Current version.","format":"rdoc","value":"\"0.3.2\"","tags":{},"files":["/lib/strmask.rb"]},"String::Mask::ESC":{"!":"constant","path":"String::Mask::ESC","name":"ESC","namespace":"String::Mask","comment":"Substitue (TODO: rename)","format":"rdoc","value":"\"\\032\"","tags":{},"files":["/lib/strmask.rb"]},"String::Mask.[]":{"!":"method","declarations":["class","public"],"path":"String::Mask.[]","name":"[]","namespace":"String::Mask","comment":"New Mask.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"[](.)","arguments":[{"name":"string"},{"name":"re","default":"nil"}]}],"returns":[],"file":"/lib/strmask.rb","line":31,"source":"def self.[](string, re=nil)\n  new(string, re)\nend","language":"ruby","dynamic":true,"tags":{"param":"Single character string used to mark empty slots."}},"String::Mask#initialize":{"!":"method","declarations":["instance","public"],"path":"String::Mask#initialize","name":"initialize","namespace":"String::Mask","comment":"Initialize new string mask.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(string, re=nil)","arguments":[{"name":"string"},{"name":"re","default":"nil"}]}],"returns":[{"type":"Mask","comment":"a new instance of Mask"}],"file":"/lib/strmask.rb","line":43,"source":"def initialize(string, re=nil)\n  @to_str = string.dup\n  @re     = re\n  mask!(re) if re\nend","language":"ruby","dynamic":true,"tags":{"param":"Single character string used to mark empty slots."}},"String::Mask#to_str":{"!":"method","declarations":["instance","public"],"path":"String::Mask#to_str","name":"to_str","namespace":"String::Mask","comment":"The underlying string object.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"to_str()","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":52,"source":"def to_str\n  @to_str\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#to_s":{"!":"method","declarations":["instance","public"],"path":"String::Mask#to_s","name":"to_s","namespace":"String::Mask","comment":"TODO: Should this use the escape character or not?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"to_s()","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":57,"source":"def to_s\n  @to_str.gsub(ESC, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#inspect":{"!":"method","declarations":["instance","public"],"path":"String::Mask#inspect","name":"inspect","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":62,"source":"def inspect\n  @to_str.gsub(ESC, @re).inspect\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#[]":{"!":"method","declarations":["instance","public"],"path":"String::Mask#[]","name":"[]","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"[](*a)","arguments":[{"name":"*a"}]}],"returns":[],"file":"/lib/strmask.rb","line":67,"source":"def [](*a)\n  to_str[*a]\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#mask":{"!":"method","declarations":["instance","public"],"path":"String::Mask#mask","name":"mask","namespace":"String::Mask","comment":"Create a new mask with the same underlying string, but\nusing a different empty slot.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mask(re)","arguments":[{"name":"re"}]}],"returns":[],"file":"/lib/strmask.rb","line":77,"source":"def mask(re)\n  self.class.new(to_str,re)\nend","language":"ruby","dynamic":true,"tags":{"param":"Single character string used to mark empty slots."}},"String::Mask#mask!":{"!":"method","declarations":["instance","public"],"path":"String::Mask#mask!","name":"mask!","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mask!(re)","arguments":[{"name":"re"}]}],"returns":[],"file":"/lib/strmask.rb","line":82,"source":"def mask!(re)\n  to_str.gsub!(re){ |s| ESC * s.size }\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#-":{"!":"method","declarations":["instance","public"],"path":"String::Mask#-","name":"-","namespace":"String::Mask","comment":"Mask subtraction. Where the characters are the same,\nthe result is \"empty\", where they differ the result\nreflects the last string.\n\n    \"abc..123\"      \"ab..789.\"\n  - \"ab..789.\"    - \"abc..123\"\n    ----------      ----------\n    \"....789.\"      \"..c..123\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"-(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":95,"source":"def -(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if to_str[i,1] == other[i,1]\n      o << ESC\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#+":{"!":"method","declarations":["instance","public"],"path":"String::Mask#+","name":"+","namespace":"String::Mask","comment":"Mask ADD. As long as there is a value other\nthen empty the character filters though.\nThe last to_str takes precedence.\n\n    \"abc..123\"      \"ab..789.\"\n  + \"ab..789.\"    + \"abc..123\"\n    ----------      ----------\n    \"abc.7893\"      \"abc.7123\"","format":"rdoc","aliases":["String::Mask#|"],"singleton":false,"interfaces":[{"signature":"+(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":119,"source":"def +(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if other[i,1] == ESC\n      o << to_str[i,1]\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#|":{"!":"method","declarations":["instance","public"],"path":"String::Mask#|","name":"|","namespace":"String::Mask","comment":"Mask ADD. As long as there is a value other\nthen empty the character filters though.\nThe last to_str takes precedence.\n\n    \"abc..123\"      \"ab..789.\"\n  + \"ab..789.\"    + \"abc..123\"\n    ----------      ----------\n    \"abc.7893\"      \"abc.7123\"\n\nMask OR is the same as ADD.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"+(other)","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":135,"source":"def +(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if other[i,1] == ESC\n      o << to_str[i,1]\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#*":{"!":"method","declarations":["instance","public"],"path":"String::Mask#*","name":"*","namespace":"String::Mask","comment":"Mask XAND. Where the characters are the same, the\nresult is the same, where they differ the result\nreflects the later.\n\n    \"abc..123\"      \"ab..789.\"\n  * \"ab..789.\"    * \"abc..123\"\n    ----------      ----------\n    \"ab..789.\"      \"abc..123\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"*(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":146,"source":"def *(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if (c = to_str[i,1]) == other[i,1]\n      o << c\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#&":{"!":"method","declarations":["instance","public"],"path":"String::Mask#&","name":"&","namespace":"String::Mask","comment":"Mask AND. Only where they are\nthen same filters through.\n\n    \"abc..123\"      \"ab..789.\"\n  & \"ab..789.\"    | \"abc..123\"\n    ----------      ----------\n    \"ab......\"      \"ab......\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"&(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":169,"source":"def &(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if (c = to_str[i,1]) == other[i,1]\n      o << c\n    else\n      o << ESC\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#^":{"!":"method","declarations":["instance","public"],"path":"String::Mask#^","name":"^","namespace":"String::Mask","comment":"Mask XOR operation. Only where there\nis an empty slot will the value filter.\n\n    \"abc..123\"      \"ab..789.\"\n  | \"ab..789.\"    | \"abc..123\"\n    ----------      ----------\n    \"..c.7..3\"      \"..c.7..3\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"^(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":192,"source":"def ^(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if to_str[i,1] == ESC\n      o << other[i,1]\n    elsif other[i,1] == ESC\n      o << to_str[i,1]\n    else\n      o << ESC\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#==":{"!":"method","declarations":["instance","public"],"path":"String::Mask#==","name":"==","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"==(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":210,"source":"def ==(other)\n  case other\n  when Mask\n    to_str == other.to_str\n  else\n    to_str == other.to_s\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#apply":{"!":"method","declarations":["instance","public"],"path":"String::Mask#apply","name":"apply","namespace":"String::Mask","comment":"Apply a method to the internal string and return\na new mask.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"apply(s=nil, *a, &b)","arguments":[{"name":"s","default":"nil"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/strmask.rb","line":221,"source":"def apply(s=nil, *a, &b)\n  if s\n    to_str.send(s,*a,&b).to_mask\n  else\n    @_self ||= Functor.new do |op, *a|\n      to_str.send(op,*a).to_mask\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#replace":{"!":"method","declarations":["instance","public"],"path":"String::Mask#replace","name":"replace","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"replace(string)","arguments":[{"name":"string"}]}],"returns":[],"file":"/lib/strmask.rb","line":232,"source":"def replace(string)\n  @to_str = string.to_s\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#method_missing":{"!":"method","declarations":["instance","public"],"path":"String::Mask#method_missing","name":"method_missing","namespace":"String::Mask","comment":"Delegate any missing methods to underlying string.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"method_missing(s, *a, &b)","arguments":[{"name":"s"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/strmask.rb","line":255,"source":"def method_missing(s, *a, &b)\n  begin\n    to_str.send(s, *a, &b)\n  rescue NoMethodError\n    super(s, *a, &b)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#convert":{"!":"method","declarations":["instance","private"],"path":"String::Mask#convert","name":"convert","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"convert(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":265,"source":"def convert(other)\n  case other\n  when Mask\n    other\n  else\n    self.class.new(other.to_s, @re)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"/README.rdoc":{"!":"document","path":"README.rdoc","name":"README.rdoc","mtime":"2011-10-26 02:22:06 -0400","text":"= String::Mask\n\n{Homepage}[http://rubyworks.github.com/strmask] |\n{Source Code}[http://github.com/rubyworks/strmask]\n\n{<img src=\"http://travis-ci.org/rubyworks/strmask.png\" />}[http://travis-ci.org/rubyworks/strmask]\n\n\n== DESCRIPTION\n\nMask provides a string utility to manipulate strings\nin logicomathematical manner, ie. add, subtract, xor,\netc.\n\n\n== SYNOPSIS\n\nMask objects can be created explicitly via #new.\n\n  m1 = String::Mask.new(\"abc..123\", '.')\n  m2 = String::Mask.new(\"ab..789.\", '.')\n  m1 - m2                             #=> \"....789.\"\n\nBut the String#mask extension is much easier to use.\n\n  m1 = \"abc..123\".mask('.')\n  m2 = \"ab..789.\".mask('.')\n  m1 * m2                             #=> \"ab..789.\"\n\nThe second operand can be a normal String. Mask will assume\nit repesents another mask akin to the first.\n\n  \"abc..123\".mask('.') + \"ab..789.\"   #=> \"abc.7893\"\n\n\n== INSTALL\n\nTo install with RubyGems simply open a console and type:\n\n  $ gem install strmask\n\n\n== COPYRIGHTS\n\nCopyright (c) 2009 Thomas Sawyer, Rubyworks\n\nThis program is ditributed unser the terms of the *FreeBSD* license.\n\nSee the NOTICE.rdoc file for details.\n\n","format":"text/rdoc"},"/HISTORY.rdoc":{"!":"document","path":"HISTORY.rdoc","name":"HISTORY.rdoc","mtime":"2011-10-27 19:24:58 -0400","text":"= RELEASE HISTORY\n\n== 0.3.2 / 2011-10-27\n\nFixed bug that prevented plain strings from being coerced\ninto masks. This release also brings the build system up\nto date with latest tools. (Note: 0.3.1 was botched).\n\nChanges:\n\n* Fixed issue with plain strings not being coerced.\n* Modernize build configuration.\n\n\n== 0.3.0 / 2010-04-18\n\nThis release changes #to_s and #inspect so they\nre-insert the escape charater into the return string.\n\nChanges:\n\n* Changed #inspect to reinsert escape character.\n* Changed #to_s to reinsert escape character.\n\n\n== 0.2.1 / 2010-02-22\n\nThis is the initial public release of String::Mask.\nThis library was spun-off from Ruby Facets.\n\nChanges:\n\n* Happy Birthday!\n\n","format":"text/rdoc"},"/QED.rdoc":{"!":"document","path":"QED.rdoc","name":"QED.rdoc","mtime":"2011-10-27 19:26:15 -0400","text":"= String Masking\n\n    require 'strmask'\n\nThere are a few ways to create a string mask.\n\n    x1 = String::Mask.new(\"abc..123\", '.')\n    x2 = String::Mask[\"abc..123\", '.']\n    x3 = \"abc..123\".mask('.')\n\nAll of the above examples are equivelent.\n\n    x1.assert == x2\n    x2.assert == x3\n    x3.assert == x1\n\nNotice in all these example we specified a dot ('.') as the escaping\ncharacter. Leaving this off defaults the chracter to ASCII ESC (\"\\032\").\nASCII ESC is a good choice for real world usage, but for demonstration\npuposes a dot is clearly much easier to read.\n\nWe will use the folowing two string masks to demonstrate the various masking\noperators below.\n\n    x1 = \"abc..123\".mask('.')\n    x2 = \"ab..789.\".mask('.')\n\nFor Addition, as long as there is a value other then empty slot the character\nfilters though, with the last string taking precedence.\n\n    (x1 + x2)  #=> \"abc.7893\".mask('.')\n    (x2 + x1)  #=> \"abc.7123\".mask('.')\n\nThe OR operator is the same as addition.\n\n    (x1 | x2)  #=> \"abc.7893\".mask('.')\n    (x2 | x1)  #=> \"abc.7123\".mask('.')\n\nFor Subtraction, where the characters are the same, the result is empty, where\nthey differ the result reflects the last string.\n\n    (x1 - x2)  #=> \"....789.\".mask('.')\n    (x2 - x1)  #=> \"..c..123\".mask('.')\n\nFor Multiplication (Exclusive AND), where the characters are the same the\nresult is the same, where they differ the result reflects the later.\n\n    (x1 * x2)  #=> \"ab..789.\".mask('.')\n    (x2 * x1)  #=> \"abc..123\".mask('.')\n\nThe AND operator, only slots that are the same (using ==) filter through.\n\n    (x1 & x2)  #=> \"ab......\".mask('.')\n    (x2 & x1)  #=> \"ab......\".mask('.')\n\nThe XOR operator, only where there is an empty slot will the value filter\nthrough.\n\n    (x1 ^ x2)  #=> \"..c.7..3\".mask('.')\n    (x2 ^ x1)  #=> \"..c.7..3\".mask('.')\n\n\n","format":"text/rdoc"},"/NOTICE.rdoc":{"!":"document","path":"NOTICE.rdoc","name":"NOTICE.rdoc","mtime":"2011-10-26 02:22:18 -0400","text":"= COPYRIGHT NOTICES\n\n== String Mask\n\nCopyright:: (c) 2009 Thomas Sawyer, Rubyworks\nLicense:: BSD-2-Clause\nWebsite:: http://rubyworks.github.com/strmask\n\n    Copyright 2009 Thomas Sawyer. All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are met:\n\n       1. Redistributions of source code must retain the above copyright notice,\n          this list of conditions and the following disclaimer.\n\n       2. Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n    NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n    OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n","format":"text/rdoc"},"/lib/strmask.rb":{"!":"script","path":"lib/strmask.rb","name":"strmask.rb","mtime":"2011-10-26 02:43:30 -0400","source":"#require 'facets/functor'\n\nclass String\n\n  # Create a mask.\n  def mask(re=nil)\n    Mask.new(self,re)\n  end\n\n  # = Mask\n  #\n  #--\n  # TODO: Probably need to create a proper #hash method.\n  #++\n  class Mask\n\n    # Current version.\n    VERSION = \"0.3.2\"  # :erb: VERSION = \"<%= version %>\"\n\n    # Substitue (TODO: rename)\n    ESC = \"\\032\" # ASCII SUBSTITUTE\n\n    # New Mask.\n    #\n    # @param [String] string\n    #   Any regular or masked string.\n    #\n    # @param [String] re\n    #   Single character string used to mark empty slots.\n    #\n    def self.[](string, re=nil)\n      new(string, re)\n    end\n\n    # Initialize new string mask.\n    #\n    # @param [String] string\n    #   Any regular or masked string.\n    #\n    # @param [String] re\n    #   Single character string used to mark empty slots.\n    #\n    def initialize(string, re=nil)\n      @to_str = string.dup\n      @re     = re\n      mask!(re) if re\n    end\n\n  public\n\n    # The underlying string object.\n    def to_str\n      @to_str\n    end\n\n    # TODO: Should this use the escape character or not?\n    def to_s\n      @to_str.gsub(ESC, @re)\n    end\n\n    #\n    def inspect\n      @to_str.gsub(ESC, @re).inspect\n    end\n\n    #\n    def [](*a)\n      to_str[*a]\n    end\n\n    # Create a new mask with the same underlying string, but\n    # using a different empty slot.\n    #\n    # @param [String] re\n    #   Single character string used to mark empty slots.\n    #\n    def mask(re)\n      self.class.new(to_str,re)\n    end\n\n    #\n    def mask!(re)\n      to_str.gsub!(re){ |s| ESC * s.size }\n    end\n\n    # Mask subtraction. Where the characters are the same,\n    # the result is \"empty\", where they differ the result\n    # reflects the last string.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   - \"ab..789.\"    - \"abc..123\"\n    #     ----------      ----------\n    #     \"....789.\"      \"..c..123\"\n    #\n    def -(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if to_str[i,1] == other[i,1]\n          o << ESC\n        else\n          o << other[i,1]\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask ADD. As long as there is a value other\n    # then empty the character filters though.\n    # The last to_str takes precedence.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   + \"ab..789.\"    + \"abc..123\"\n    #     ----------      ----------\n    #     \"abc.7893\"      \"abc.7123\"\n    #\n    def +(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if other[i,1] == ESC\n          o << to_str[i,1]\n        else\n          o << other[i,1]\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask OR is the same as ADD.\n    alias_method :|, :+\n\n    # Mask XAND. Where the characters are the same, the\n    # result is the same, where they differ the result\n    # reflects the later.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   * \"ab..789.\"    * \"abc..123\"\n    #     ----------      ----------\n    #     \"ab..789.\"      \"abc..123\"\n    #\n    def *(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if (c = to_str[i,1]) == other[i,1]\n          o << c\n        else\n          o << other[i,1]\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask AND. Only where they are\n    # then same filters through.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   & \"ab..789.\"    | \"abc..123\"\n    #     ----------      ----------\n    #     \"ab......\"      \"ab......\"\n    #\n    def &(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if (c = to_str[i,1]) == other[i,1]\n          o << c\n        else\n          o << ESC\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask XOR operation. Only where there\n    # is an empty slot will the value filter.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   | \"ab..789.\"    | \"abc..123\"\n    #     ----------      ----------\n    #     \"..c.7..3\"      \"..c.7..3\"\n    #\n    def ^(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if to_str[i,1] == ESC\n          o << other[i,1]\n        elsif other[i,1] == ESC\n          o << to_str[i,1]\n        else\n          o << ESC\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    #\n    def ==(other)\n      case other\n      when Mask\n        to_str == other.to_str\n      else\n        to_str == other.to_s\n      end\n    end\n\n    # Apply a method to the internal string and return\n    # a new mask.\n    def apply(s=nil, *a, &b)\n      if s\n        to_str.send(s,*a,&b).to_mask\n      else\n        @_self ||= Functor.new do |op, *a|\n          to_str.send(op,*a).to_mask\n        end\n      end\n    end\n\n    #\n    def replace(string)\n      @to_str = string.to_s\n    end\n\n    #\n    #def instance_delegate\n    #  @to_str\n    #end\n\n    # Functor on the interal string.\n    #def self\n    #  @_self ||= Functor.new do |op, *a|\n    #    @to_str = @to_str.send(op, *a)\n    #  end\n    #end\n\n    #\n    #def coerce(other)\n    #  [self, other.mask(@re)]\n    #end\n\n    # Delegate any missing methods to underlying string.\n    #\n    def method_missing(s, *a, &b)\n      begin\n        to_str.send(s, *a, &b)\n      rescue NoMethodError\n        super(s, *a, &b)\n      end\n    end\n\n    private\n\n    def convert(other)\n      case other\n      when Mask\n        other\n      else\n        self.class.new(other.to_s, @re)\n      end\n    end\n\n  end\n\nend\n\n","language":"text/x-ruby"}}
