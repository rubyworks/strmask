{"(metadata)":{"authors":[{"name":"Thomas Sawyer","email":"transfire@gmail.com"}],"copyrights":[{"holder":"Thomas Sawyer","year":"2009","license":"BSD-2-Clause"}],"replacements":[],"conflicts":[],"requirements":[{"name":"qed","groups":["test"],"development":true},{"name":"syckle","groups":["build"],"development":true}],"dependencies":[],"repositories":[],"resources":{"home":"http://rubyworks.github.com/strmask","code":"http://github.com/rubyworks/strmask","mail":"http://groups.google.com/group/rubyworks-mailinglist"},"load_path":["lib"],"extra":{"company":"RubyWorks","manifest":"MANIFEST"},"source":[],"alternatives":[],"revision":0,"title":"String::Mask","name":"strmask","summary":"String Algebra","created":"2009-07-19","description":"String::Mask provides a kind-of string algebra useful for manipulating strings in in comparitive ways, eg. add, subtract, xor, etc.","version":"0.3.1","date":"2011-08-22","path":"(metadata)","markup":"rdoc"},"String":{"!":"class","superclass":"Object","path":"String","name":"String","namespace":"","comment":"require 'facets/functor'","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["String::Mask"],"methods":["String#mask"],"accessors":[],"files":["/lib/strmask.rb"],"tags":{}},"String#mask":{"!":"method","declarations":["instance","public"],"path":"String#mask","name":"mask","namespace":"String","comment":"Create a mask.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mask(re=nil)","arguments":[{"name":"re","default":"nil"}]}],"returns":[],"file":"/lib/strmask.rb","line":6,"source":"def mask(re=nil)\n  Mask.new(self,re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask":{"!":"class","superclass":"Object","path":"String::Mask","name":"Mask","namespace":"String","comment":"= Mask\n\n--\nTODO: Probably need to create a proper #hash method.\n++","format":"rdoc","constants":["String::Mask::VERSION","String::Mask::ESC"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["String::Mask.[]","String::Mask#initialize","String::Mask#to_str","String::Mask#to_s","String::Mask#inspect","String::Mask#[]","String::Mask#mask","String::Mask#mask!","String::Mask#-","String::Mask#+","String::Mask#|","String::Mask#*","String::Mask#&","String::Mask#^","String::Mask#==","String::Mask#apply","String::Mask#replace","String::Mask#method_missing","String::Mask#convert"],"accessors":[],"files":["/lib/strmask.rb"],"tags":{}},"String::Mask::VERSION":{"!":"constant","path":"String::Mask::VERSION","name":"VERSION","namespace":"String::Mask","comment":"current version","format":"rdoc","value":"\"0.3.1\"","tags":{},"files":["/lib/strmask.rb"]},"String::Mask::ESC":{"!":"constant","path":"String::Mask::ESC","name":"ESC","namespace":"String::Mask","comment":"substitue (TODO: rename)","format":"rdoc","value":"\"\\032\"","tags":{},"files":["/lib/strmask.rb"]},"String::Mask.[]":{"!":"method","declarations":["class","public"],"path":"String::Mask.[]","name":"[]","namespace":"String::Mask","comment":"ASCII SUBSTITUTE","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"[](.)","arguments":[{"name":"string"},{"name":"re","default":"nil"}]}],"returns":[],"file":"/lib/strmask.rb","line":23,"source":"def self.[](string, re=nil)\n  new(string, re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#initialize":{"!":"method","declarations":["instance","public"],"path":"String::Mask#initialize","name":"initialize","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(string, re=nil)","arguments":[{"name":"string"},{"name":"re","default":"nil"}]}],"returns":[{"type":"Mask","comment":"a new instance of Mask"}],"file":"/lib/strmask.rb","line":27,"source":"def initialize(string, re=nil)\n  @to_str = string.dup\n  @re     = re\n  mask!(re) if re\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#to_str":{"!":"method","declarations":["instance","public"],"path":"String::Mask#to_str","name":"to_str","namespace":"String::Mask","comment":"The underlying string object.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"to_str()","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":36,"source":"def to_str\n  @to_str\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#to_s":{"!":"method","declarations":["instance","public"],"path":"String::Mask#to_s","name":"to_s","namespace":"String::Mask","comment":"TODO: Should this use the escape character or not?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"to_s()","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":41,"source":"def to_s\n  @to_str.gsub(ESC, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#inspect":{"!":"method","declarations":["instance","public"],"path":"String::Mask#inspect","name":"inspect","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":46,"source":"def inspect\n  @to_str.gsub(ESC, @re).inspect\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#[]":{"!":"method","declarations":["instance","public"],"path":"String::Mask#[]","name":"[]","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"[](*a)","arguments":[{"name":"*a"}]}],"returns":[],"file":"/lib/strmask.rb","line":51,"source":"def [](*a)\n  to_str[*a]\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#mask":{"!":"method","declarations":["instance","public"],"path":"String::Mask#mask","name":"mask","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mask(re)","arguments":[{"name":"re"}]}],"returns":[],"file":"/lib/strmask.rb","line":55,"source":"def mask(re)\n  self.class.new(to_str,re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#mask!":{"!":"method","declarations":["instance","public"],"path":"String::Mask#mask!","name":"mask!","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mask!(re)","arguments":[{"name":"re"}]}],"returns":[],"file":"/lib/strmask.rb","line":59,"source":"def mask!(re)\n  to_str.gsub!(re){ |s| ESC * s.size }\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#-":{"!":"method","declarations":["instance","public"],"path":"String::Mask#-","name":"-","namespace":"String::Mask","comment":"Mask subtraction. Where the characters are the same,\nthe result is \"empty\", where they differ the result\nreflects the last string.\n\n    \"abc..123\"      \"ab..789.\"\n  - \"ab..789.\"    - \"abc..123\"\n    ----------      ----------\n    \"....789.\"      \"..c..123\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"-(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":72,"source":"def -(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if to_str[i,1] == other[i,1]\n      o << ESC\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#+":{"!":"method","declarations":["instance","public"],"path":"String::Mask#+","name":"+","namespace":"String::Mask","comment":"Mask ADD. As long as there is a value other\nthen empty the character filters though.\nThe last to_str takes precedence.\n\n    \"abc..123\"      \"ab..789.\"\n  + \"ab..789.\"    + \"abc..123\"\n    ----------      ----------\n    \"abc.7893\"      \"abc.7123\"","format":"rdoc","aliases":["String::Mask#|"],"singleton":false,"interfaces":[{"signature":"+(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":96,"source":"def +(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if other[i,1] == ESC\n      o << to_str[i,1]\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#|":{"!":"method","declarations":["instance","public"],"path":"String::Mask#|","name":"|","namespace":"String::Mask","comment":"Mask ADD. As long as there is a value other\nthen empty the character filters though.\nThe last to_str takes precedence.\n\n    \"abc..123\"      \"ab..789.\"\n  + \"ab..789.\"    + \"abc..123\"\n    ----------      ----------\n    \"abc.7893\"      \"abc.7123\"\n\nMask OR is the same as ADD.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"+(other)","arguments":[]}],"returns":[],"file":"/lib/strmask.rb","line":112,"source":"def +(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if other[i,1] == ESC\n      o << to_str[i,1]\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#*":{"!":"method","declarations":["instance","public"],"path":"String::Mask#*","name":"*","namespace":"String::Mask","comment":"Mask XAND. Where the characters are the same, the\nresult is the same, where they differ the result\nreflects the later.\n\n    \"abc..123\"      \"ab..789.\"\n  * \"ab..789.\"    * \"abc..123\"\n    ----------      ----------\n    \"ab..789.\"      \"abc..123\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"*(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":123,"source":"def *(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if (c = to_str[i,1]) == other[i,1]\n      o << c\n    else\n      o << other[i,1]\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#&":{"!":"method","declarations":["instance","public"],"path":"String::Mask#&","name":"&","namespace":"String::Mask","comment":"Mask AND. Only where they are\nthen same filters through.\n\n    \"abc..123\"      \"ab..789.\"\n  & \"ab..789.\"    | \"abc..123\"\n    ----------      ----------\n    \"ab......\"      \"ab......\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"&(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":146,"source":"def &(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if (c = to_str[i,1]) == other[i,1]\n      o << c\n    else\n      o << ESC\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#^":{"!":"method","declarations":["instance","public"],"path":"String::Mask#^","name":"^","namespace":"String::Mask","comment":"Mask XOR operation. Only where there\nis an empty slot will the value filter.\n\n    \"abc..123\"      \"ab..789.\"\n  | \"ab..789.\"    | \"abc..123\"\n    ----------      ----------\n    \"..c.7..3\"      \"..c.7..3\"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"^(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":169,"source":"def ^(other)\n  other = convert(other)\n  i = 0\n  o = ''\n  while i < to_str.size\n    if to_str[i,1] == ESC\n      o << other[i,1]\n    elsif other[i,1] == ESC\n      o << to_str[i,1]\n    else\n      o << ESC\n    end\n    i += 1\n  end\n  self.class.new(o, @re)\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#==":{"!":"method","declarations":["instance","public"],"path":"String::Mask#==","name":"==","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"==(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":187,"source":"def ==(other)\n  case other\n  when Mask\n    to_str == other.to_str\n  else\n    to_str == other.to_s\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#apply":{"!":"method","declarations":["instance","public"],"path":"String::Mask#apply","name":"apply","namespace":"String::Mask","comment":"Apply a method to the internal string and return\na new mask.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"apply(s=nil, *a, &b)","arguments":[{"name":"s","default":"nil"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/strmask.rb","line":198,"source":"def apply(s=nil, *a, &b)\n  if s\n    to_str.send(s,*a,&b).to_mask\n  else\n    @_self ||= Functor.new do |op, *a|\n      to_str.send(op,*a).to_mask\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#replace":{"!":"method","declarations":["instance","public"],"path":"String::Mask#replace","name":"replace","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"replace(string)","arguments":[{"name":"string"}]}],"returns":[],"file":"/lib/strmask.rb","line":209,"source":"def replace(string)\n  @to_str = string.to_s\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#method_missing":{"!":"method","declarations":["instance","public"],"path":"String::Mask#method_missing","name":"method_missing","namespace":"String::Mask","comment":"Delegate any missing methods to underlying string.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"method_missing(s, *a, &b)","arguments":[{"name":"s"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/strmask.rb","line":232,"source":"def method_missing(s, *a, &b)\n  begin\n    to_str.send(s, *a, &b)\n  rescue NoMethodError\n    super(s, *a, &b)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"String::Mask#convert":{"!":"method","declarations":["instance","private"],"path":"String::Mask#convert","name":"convert","namespace":"String::Mask","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"convert(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/strmask.rb","line":242,"source":"def convert(other)\n  case other\n  when Mask\n    other\n  else\n    self.class.new(other.to_s, @re)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"/README.rdoc":{"!":"document","path":"README.rdoc","name":"README.rdoc","mtime":"2010-10-13 14:27:23 -0400","text":"= String::Mask\n\n* home: http://rubyworks.github.com/strmask\n* work: http://github.com/rubyworks/strmask\n\n\n== DESCRIPTION\n\nMask provides a string utility to manipulate strings\nin logicomathematical manner, ie. add, subtract, xor,\netc.\n\n== SYNOPSIS\n\nMask objects can be created explicitly via #new.\n\n  m1 = String::Mask.new(\"abc..123\", '.')\n  m2 = String::Mask.new(\"ab..789.\", '.')\n  m1 - m2                             #=> \"....789.\"\n\nBut the String#mask extension is much easier to use.\n\n  m1 = \"abc..123\".mask('.')\n  m2 = \"ab..789.\".mask('.')\n  m1 * m2                             #=> \"ab..789.\"\n\nThe second operand can be a normal String. Mask will assume\nit repesents another mask akin to the first.\n\n  \"abc..123\".mask('.') + \"ab..789.\"   #=> \"abc.7893\"\n\n\n== HOW TO INSTALL\n\nTo install with RubyGems simply open a console and type:\n\n  gem install strmask\n\n\n== COPYRIGHT\n\nCopyright (c) 2009 Thomas Sawyer\n\nThis program is ditributed unser the terms of the Apache 2.0 license.\n\nSee the LICENSE file for details.\n\n","format":"text/rdoc"},"/lib/strmask.rb":{"!":"script","path":"lib/strmask.rb","name":"strmask.rb","mtime":"2010-11-26 15:13:33 -0500","source":"#require 'facets/functor'\n\nclass String\n\n  # Create a mask.\n  def mask(re=nil)\n    Mask.new(self,re)\n  end\n\n  # = Mask\n  #\n  #--\n  # TODO: Probably need to create a proper #hash method.\n  #++\n  class Mask\n\n    # current version\n    VERSION = \"0.3.1\"\n\n    # substitue (TODO: rename)\n    ESC = \"\\032\" # ASCII SUBSTITUTE\n\n    def self.[](string, re=nil)\n      new(string, re)\n    end\n\n    def initialize(string, re=nil)\n      @to_str = string.dup\n      @re     = re\n      mask!(re) if re\n    end\n\n  public\n\n    # The underlying string object.\n    def to_str\n      @to_str\n    end\n\n    # TODO: Should this use the escape character or not?\n    def to_s\n      @to_str.gsub(ESC, @re)\n    end\n\n    #\n    def inspect\n      @to_str.gsub(ESC, @re).inspect\n    end\n\n    #\n    def [](*a)\n      to_str[*a]\n    end\n\n    def mask(re)\n      self.class.new(to_str,re)\n    end\n\n    def mask!(re)\n      to_str.gsub!(re){ |s| ESC * s.size }\n    end\n\n    # Mask subtraction. Where the characters are the same,\n    # the result is \"empty\", where they differ the result\n    # reflects the last string.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   - \"ab..789.\"    - \"abc..123\"\n    #     ----------      ----------\n    #     \"....789.\"      \"..c..123\"\n    #\n    def -(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if to_str[i,1] == other[i,1]\n          o << ESC\n        else\n          o << other[i,1]\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask ADD. As long as there is a value other\n    # then empty the character filters though.\n    # The last to_str takes precedence.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   + \"ab..789.\"    + \"abc..123\"\n    #     ----------      ----------\n    #     \"abc.7893\"      \"abc.7123\"\n    #\n    def +(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if other[i,1] == ESC\n          o << to_str[i,1]\n        else\n          o << other[i,1]\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask OR is the same as ADD.\n    alias_method :|, :+\n\n    # Mask XAND. Where the characters are the same, the\n    # result is the same, where they differ the result\n    # reflects the later.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   * \"ab..789.\"    * \"abc..123\"\n    #     ----------      ----------\n    #     \"ab..789.\"      \"abc..123\"\n    #\n    def *(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if (c = to_str[i,1]) == other[i,1]\n          o << c\n        else\n          o << other[i,1]\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask AND. Only where they are\n    # then same filters through.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   & \"ab..789.\"    | \"abc..123\"\n    #     ----------      ----------\n    #     \"ab......\"      \"ab......\"\n    #\n    def &(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if (c = to_str[i,1]) == other[i,1]\n          o << c\n        else\n          o << ESC\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    # Mask XOR operation. Only where there\n    # is an empty slot will the value filter.\n    #\n    #     \"abc..123\"      \"ab..789.\"\n    #   | \"ab..789.\"    | \"abc..123\"\n    #     ----------      ----------\n    #     \"..c.7..3\"      \"..c.7..3\"\n    #\n    def ^(other)\n      other = convert(other)\n      i = 0\n      o = ''\n      while i < to_str.size\n        if to_str[i,1] == ESC\n          o << other[i,1]\n        elsif other[i,1] == ESC\n          o << to_str[i,1]\n        else\n          o << ESC\n        end\n        i += 1\n      end\n      self.class.new(o, @re)\n    end\n\n    #\n    def ==(other)\n      case other\n      when Mask\n        to_str == other.to_str\n      else\n        to_str == other.to_s\n      end\n    end\n\n    # Apply a method to the internal string and return\n    # a new mask.\n    def apply(s=nil, *a, &b)\n      if s\n        to_str.send(s,*a,&b).to_mask\n      else\n        @_self ||= Functor.new do |op, *a|\n          to_str.send(op,*a).to_mask\n        end\n      end\n    end\n\n    #\n    def replace(string)\n      @to_str = string.to_s\n    end\n\n    #\n    #def instance_delegate\n    #  @to_str\n    #end\n\n    # Functor on the interal string.\n    #def self\n    #  @_self ||= Functor.new do |op, *a|\n    #    @to_str = @to_str.send(op, *a)\n    #  end\n    #end\n\n    #\n    #def coerce(other)\n    #  [self, other.mask(@re)]\n    #end\n\n    # Delegate any missing methods to underlying string.\n    #\n    def method_missing(s, *a, &b)\n      begin\n        to_str.send(s, *a, &b)\n      rescue NoMethodError\n        super(s, *a, &b)\n      end\n    end\n\n    private\n\n    def convert(other)\n      case other\n      when Mask\n        other\n      else\n        self.class.new(other.to_s, @re)\n      end\n    end\n\n  end\n\nend\n\n","language":"text/x-ruby"}}
